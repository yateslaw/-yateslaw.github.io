{"posts":[{"title":"二叉树中的最大路径和(hard)","text":"二叉树中的最大路径和 题目大意描述：给定一个二叉树的根节点 $root$。 要求：返回其最大路径和。 说明： 路径：被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。 路径和：路径中各节点值的总和。 树中节点数目范围是 $[1, 3 * 10^4]$。 $-1000 \\le Node.val \\le 1000$。 示例： 示例 1： 123输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6 示例 2： 123输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 思路： 每个子树内部的最大路径和是我想求的，要找出最大的 这个内部路径肯定是要走这个子树的root的，而且是要参考左右子树所提供的最大和的 想捞取子树所提供的最大和，只能走其中一个分支，因为从root伸进去子树的路径，不能拐来拐去，不能占两路便宜 只能在子树里选一条分支走，那就得判断哪个分支提供的路径和更大 所以每个递归调用都要返回出【提供给父节点的最大路径和】，它用于计算每个递归调用都要算一下的内部最大路径和 复盘总结： 递归一个树，会对每个子树做同样的事（你写的处理逻辑），所以你需要思考要对每个子树做什么事，即思考子问题是什么，大问题怎么拆解成子问题。 通过求出每个子树对外提供的最大路径和（返回出来给父节点），从递归树底部向上，不断求出了每个子树内部的最大路径和，后者是求解的目标，它的求解需要前者，搞清楚二者的关系。 每个子树的内部最大路径和，都挑战一下最大纪录，递归结束时，最大纪录就有了。 思考递归问题，别纠结细节实现，内部细节是子递归帮你去做的，应结合求解的目标，自顶而下、屏蔽细节地思考，思考递归子问题的定义。随着递归出栈，子问题自下而上地解决，最后解决了整个问题。 要做的只是写好递归的处理逻辑，怎么处理当前子树？需要返回什么吗？怎么设置递归的出口？ 没有思路的时候，试着画画递归树找思路。就算做对了，画图也能加深对递归算法的理解。 123456789101112131415161718192021func maxPathSum(root *TreeNode) int { maxSum := math.MinInt32 var dfs func(*TreeNode) int dfs = func(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) innerMaxSum := left + right + root.Val maxSum = max(maxSum, innerMaxSum) outputMaxSum := root.Val + max(left, right) return max(outputMaxSum, 0) } dfs(root) return maxSum}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"不同的二叉搜索树","text":"不同的二叉搜索树 题目大意描述：给定一个整数 $n$。 要求：求以 $1$ 到 $n$ 为节点构成的「二叉搜索树」有多少种？ 说明： 1 &lt;= n &lt;= 19。 示例： 示例 1： 12输入：n = 3输出：5 示例 2： 12输入：n = 1输出：1 思路： 假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)G(n-1)+G(1)(n-2)+…+G(n-1)*G(0) 123456789101112func numTrees(n int) int { res := make([]int, n + 1) res[0] = 1 res[1] = 1 for i := 2; i &lt;= n; i++ { for j := 1; j &lt;=i; j ++ { res[i] += res[j-1] * res[i - j] } } return res[n]}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"二叉树的最大深度(easy)","text":"二叉树的最大深度 题目大意描述：给定一个二叉树的根节点 root。 要求：找出该二叉树的最大深度。 说明： 二叉树的深度：根节点到最远叶子节点的最长路径上的节点数。 叶子节点：没有子节点的节点。 示例： 示例 1： 123456789输入：[3,9,20,null,null,15,7]对应二叉树 3 / \\ 9 20 / \\ 15 7输出：3解释：该二叉树的最大深度为 3 思路： 如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为max(l,r)+1. 12345678910111213func maxDepth(root *TreeNode) int { if root == nil { return 0 } left := maxDepth(root.Left) right := maxDepth(root.Right) return max(left, right) + 1}func max(a, b int) int { if a &gt; b { return a } return b}","link":"/2024/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"},{"title":"二叉树的最近公共祖先(mid)","text":"二叉树的最近公共祖先 题目大意给定一个二叉树的根节点 root，再给定两个指定节点 p、q。 要求：找到两个指定节点 p、q 的最近公共祖先。 祖先：若节点 p 在节点 node 的左子树或右子树中，或者 p == node，则称 node 是 p 的祖先。 最近公共祖先：对于树的两个节点 p、q，最近公共祖先表示为一个节点 lca_node，满足 lca_node 是 p、q 的祖先且 lca_node 的深度尽可能大（一个节点也可以是自己的祖先） 解题思路设 lca_node 为节点 p、q 的最近公共祖先。则 lca_node 只能是下面几种情况： p、q 在 lca_node 的子树中，且分别在 lca_node 的两侧子树中。 p = lca_node，且 q 在 lca_node 的左子树或右子树中。 q = lca_node，且 p 在 lca_node 的左子树或右子树中。 下面递归求解 lca_node。递归需要满足以下条件： 如果 p、q 都不为空，则返回 p、q 的公共祖先。 如果 p、q 只有一个存在，则返回存在的一个。 如果 p、q 都不存在，则返回存在的一个。 具体思路为： 如果当前节点 node 为 None，则说明 p、q 不在 node 的子树中，不可能为公共祖先，直接返回 None。 如果当前节点 node 等于 p 或者 q，那么 node 就是 p、q 的最近公共祖先，直接返回 node 递归遍历左子树、右子树，并判断左右子树结果。 如果左子树为空，则返回右子树。 如果右子树为空，则返回左子树。 如果左右子树都不为空，则说明 p、q 在当前根节点的两侧，当前根节点就是他们的最近公共祖先。 如果左右子树都为空，则返回空。 123456789101112131415161718192021222324func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { //只要当前根节点是p和q中的任意一个，就返回（因为不能比这个更深了，再深p和q中的一个就没了） if root == nil || root == p || root == q { return root } //根节点不是p和q中的任意一个，那么就继续分别往左子树和右子树找p和q left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) //p和q都没找到，那就没有 if left == nil &amp;&amp; right == nil { return nil } //左子树没有p也没有q，就返回右子树的结果 if left == nil { return right } //右子树没有p也没有q就返回左子树的结果 if right == nil { return left } //左右子树都找到p和q了，那就说明p和q分别在左右两个子树上，所以此时的最近公共祖先就是root return root}","link":"/2024/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"二叉树的层次遍历(mid)","text":"二叉树层次遍历 题目大意给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 思路：队列遍历 首先根元素入队。 如果队列不为空，则得到当前队列的长度n, 依次从队列拉出n个元素，并将元素的左右子树节点放入队列，重复迭代直到队列为空。 12345678910111213141516171819202122232425// 时间复杂度 O（N）， 空间复杂度 O（N）func levelOrder(root *TreeNode) [][]int { ret := make([][]int, 0) if root == nil { return ret } q := []*TreeNode{root} for len(q) &gt; 0 { n := len(q) tempLevel := make([]int, n) for i := 0; i &lt; n; i++ { node := q[i] tempLevel[i] = node.Val if node.Left != nil { q = append(q, node.Left) } if node.Right != nil { q = append(q, node.Right) } } q = q[n:] ret = append(ret, tempLevel) } return ret}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"title":"二叉树的直径(easy)","text":"题目链接 0543. 二叉树的直径 - 力扣 题目大意描述：给一个二叉树的根节点 $root$。 要求：计算该二叉树的直径长度。 说明： 二叉树的直径长度：二叉树中任意两个节点路径长度中的最大值。 两节点之间的路径长度是以它们之间边的数目表示。 这条路径可能穿过也可能不穿过根节点。 示例： 示例 1： 12345678给定二叉树： 1 / \\ 2 3 / \\ 4 5 输出：3解释：该二叉树的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 解题思路思路 1：树形 DP + 深度优先搜索这道题重点是理解直径长度的定义。「二叉树的直径长度」的定义为：二叉树中任意两个节点路径长度中的最大值。并且这条路径可能穿过也可能不穿过根节点。 对于根为 $root$ 的二叉树来说，其直径长度并不简单等于「左子树高度」加上「右子树高度」。 根据路径是否穿过根节点，我们可以将二叉树分为两种： 直径长度所对应的路径穿过根节点。 直径长度所对应的路径不穿过根节点。 我们来看下图中的两个例子。 如图所示，左侧这棵二叉树就是一棵常见的平衡二叉树，其直径长度所对应的路径是穿过根节点的（$D\\rightarrow B \\rightarrow A \\rightarrow C$）。这种情况下：$\\text{二叉树的直径} = \\text{左子树高度} + \\text{右子树高度}$。 而右侧这棵特殊的二叉树，其直径长度所对应的路径是没有穿过根节点的（$F \\rightarrow D \\rightarrow B \\rightarrow E \\rightarrow G$）。这种情况下：$\\text{二叉树的直径} = \\text{所有子树中最大直径长度}$。 也就是说根为 $root$ 的二叉树的直径长度可能来自于 $\\text{左子树高度} + \\text{右子树高度}$，也可能来自于 $\\text{子树中的最大直径}$，即 $\\text{二叉树的直径} = max(\\text{左子树高度} + \\text{右子树高度}, \\quad \\text{所有子树中最大直径长度})$。 那么现在问题就变成为如何求「子树的高度」和「子树中的最大直径」。 子树的高度：我们可以利用深度优先搜索方法，递归遍历左右子树，并分别返回左右子树的高度。 子树中的最大直径：我们可以在递归求解子树高度的时候维护一个 $ans$ 变量，用于记录所有 $\\text{左子树高度} + \\text{右子树高度}$ 中的最大值。 最终 $ans$ 就是我们所求的该二叉树的最大直径，将其返回即可。 123456789101112131415161718192021func diameterOfBinaryTree(root *TreeNode) int { res := 0 var dfs func(root *TreeNode) int dfs = func(root *TreeNode) int{ if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) res = max(res, left+right+1) return max(left, right) + 1 } dfs(root) return res - 1}func max(a, b int) int { if a &gt; b { return a } return b}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"title":"二叉树的锯齿形层序遍历(mid)","text":"题目链接 0103. 二叉树的锯齿形层序遍历 - 力扣 题目大意描述：给定一个二叉树的根节点 root。 要求：返回其节点值的锯齿形层序遍历结果。 说明： 锯齿形层序遍历：从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。 示例： 示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]] 示例 2： 12输入：root = [1]输出：[[1]] 解题思路思路 1：广度优先搜索在二叉树的层序遍历的基础上需要增加一些变化。 普通广度优先搜索只取一个元素，变化后的广度优先搜索每次取出第 i 层上所有元素。 新增一个变量 odd，用于判断当前层数是奇数层，还是偶数层。从而判断元素遍历方向。 存储每层元素的 level 列表改用双端队列，如果是奇数层，则从末尾添加元素。如果是偶数层，则从头部添加元素。 具体步骤如下： 使用列表 order 存放锯齿形层序遍历结果，使用整数 odd 变量用于判断奇偶层，使用双端队列 level 存放每层元素，使用列表 queue 用于进行广度优先搜索。 将根节点放入入队列中，即 queue = [root]。 当队列 queue 不为空时，求出当前队列长度 $s_i$，并判断当前层数的奇偶性。 依次从队列中取出这 $s_i$ 个元素。 如果当前层为奇数层，如果是奇数层，则从 level 末尾添加元素。 如果当前层是偶数层，则从 level 头部添加元素。 然后将当前元素的左右子节点加入队列 queue 中，然后继续迭代。 将存储当前层元素的 level 存入答案列表 order 中。 当队列为空时，结束。返回锯齿形层序遍历结果 order。 思路 1：复杂度分析 时间复杂度：$O(n)$。其中 $n$ 是二叉树的节点数目。 空间复杂度：$O(n)$。 12345678910111213141516171819202122232425262728293031// 时间复杂度 O（N）， 空间复杂度 O（N）func zigzagLevelOrder(root *TreeNode) [][]int { ret := make([][]int, 0) if root == nil { return ret } q := []*TreeNode{root} isReverse := false for len(q) &gt; 0 { n := len(q) tempLevel := make([]int, n) for i := 0; i &lt; n; i++ { node := q[i] if isReverse { tempLevel[n-i-1] = node.Val } else { tempLevel[i] = node.Val } if node.Left != nil { q = append(q, node.Left) } if node.Right != nil { q = append(q, node.Right) } } q = q[n:] isReverse = !isReverse ret = append(ret, tempLevel) } return ret}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86/"},{"title":"对称二叉树(easy)","text":"题目链接 0101. 对称二叉树 - 力扣 题目大意描述：给定一个二叉树的根节点 root。 要求：判断该二叉树是否是左右对称的。 说明： 树中节点数目在范围 [1, 1000] 内。 100 &lt;= Node.val &lt;= 100。 示例： 示例 1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例 2： 12输入：root = [1,2,2,null,3,null,3]输出：false 解题思路思路 1：递归遍历如果一棵二叉树是对称的，那么其左子树和右子树的外侧节点的节点值应当是相等的，并且其左子树和右子树的内侧节点的节点值也应当是相等的。 那么我们可以通过递归方式，检查其左子树与右子树外侧节点和内测节点是否相等。即递归检查左子树的左子节点值与右子树的右子节点值是否相等（外侧节点值是否相等），递归检查左子树的右子节点值与右子树的左子节点值是否相等（内测节点值是否相等）。 具体步骤如下： 如果当前根节点为 None，则直接返回 True。 如果当前根节点不为 None，则调用 check(left, right) 方法递归检查其左右子树是否对称。 如果左子树节点为 None，并且右子树节点也为 None，则直接返回 True。 如果左子树节点为 None，并且右子树节点不为 None，则直接返回 False。 如果左子树节点不为 None，并且右子树节点为 None，则直接返回 False。 如果左子树节点值不等于右子树节点值，则直接返回 False。 如果左子树节点不为 None，并且右子树节点不为 None，并且左子树节点值等于右子树节点值，则： 递归检测左右子树的外侧节点是否相等。 递归检测左右子树的内测节点是否相等。 如果左右子树的外侧节点、内测节点值相等，则返回 True。 思路 1：复杂度分析 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数目。 空间复杂度：$O(n)$。递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 $n$，所以空间复杂度为 $O(n)$。 12345678910111213141516func isSymmetric(root *TreeNode) bool { if root == nil { return true } return check(root, root)}func check(t1 *TreeNode, t2 *TreeNode) bool { if t1 == nil &amp;&amp; t2 == nil { return true } if t1 == nil || t2 == nil { return false } return t1.Val == t2.Val &amp;&amp; check(t1.Left, t2.Right) &amp;&amp; check(t1.Right, t2.Left)} 思路二：迭代 1234567891011121314151617181920212223242526272829class Solution { public boolean isSymmetric(TreeNode root) { return check(root, root); } public boolean check(TreeNode u, TreeNode v) { Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.offer(u); q.offer(v); while (!q.isEmpty()) { u = q.poll(); v = q.poll(); if (u == null &amp;&amp; v == null) { continue; } if ((u == null || v == null) || (u.val != v.val)) { return false; } q.offer(u.left); q.offer(v.right); q.offer(u.right); q.offer(v.left); } return true; }}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"翻转二叉树(easy)","text":"题目链接 0226. 翻转二叉树 - 力扣 题目大意描述：给定一个二叉树的根节点 root。 要求：将该二叉树进行左右翻转。 说明： 树中节点数目范围在 [0, 100] 内。 100 &lt;= Node.val &lt;= 100。 示例： 示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 示例 2： 12输入：root = [2,1,3]输出：[2,3,1] 解题思路思路 1：递归遍历根据我们的递推三步走策略，写出对应的递归代码。 写出递推公式： 递归遍历翻转左子树。 递归遍历翻转右子树。 交换当前根节点 root 的左右子树。 明确终止条件：当前节点 root 为 None。 翻译为递归代码： 定义递归函数：invertTree(self, root) 表示输入参数为二叉树的根节点 root，返回结果为翻转后二叉树的根节点。 书写递归主体： 12345left := invertTree(root.Left)right := invertTree(root.Right)root.Left = rightroot.Right = leftreturn root 明确递归终止条件： 123if root == nil { return nil} 返回根节点 root。 12345678910func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } left := invertTree(root.Left) right := invertTree(root.Right) root.Left = right root.Right = left return root}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"算法/二叉树","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"pages":[]}