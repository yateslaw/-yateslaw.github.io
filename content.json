{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/03/17/hello-world/"},{"title":"不同的二叉搜索树","text":"不同的二叉搜索树 思路： 假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)G(n-1)+G(1)(n-2)+…+G(n-1)*G(0) 12345678910111213func numTrees(n int) int { res := make([]int, n + 1) res[0] = 1 res[1] = 1 for i := 2; i &lt;= n; i++ { for j := 1; j &lt;=i; j ++ { res[i] += res[j-1] * res[i - j] } } return res[n]}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"二叉树中的最大路径和","text":"二叉树中的最大路径和 思路： 每个子树内部的最大路径和是我想求的，要找出最大的 这个内部路径肯定是要走这个子树的root的，而且是要参考左右子树所提供的最大和的 想捞取子树所提供的最大和，只能走其中一个分支，因为从root伸进去子树的路径，不能拐来拐去，不能占两路便宜 只能在子树里选一条分支走，那就得判断哪个分支提供的路径和更大 所以每个递归调用都要返回出【提供给父节点的最大路径和】，它用于计算每个递归调用都要算一下的内部最大路径和 复盘总结： 递归一个树，会对每个子树做同样的事（你写的处理逻辑），所以你需要思考要对每个子树做什么事，即思考子问题是什么，大问题怎么拆解成子问题。 通过求出每个子树对外提供的最大路径和（返回出来给父节点），从递归树底部向上，不断求出了每个子树内部的最大路径和，后者是求解的目标，它的求解需要前者，搞清楚二者的关系。 每个子树的内部最大路径和，都挑战一下最大纪录，递归结束时，最大纪录就有了。 思考递归问题，别纠结细节实现，内部细节是子递归帮你去做的，应结合求解的目标，自顶而下、屏蔽细节地思考，思考递归子问题的定义。随着递归出栈，子问题自下而上地解决，最后解决了整个问题。 要做的只是写好递归的处理逻辑，怎么处理当前子树？需要返回什么吗？怎么设置递归的出口？ 没有思路的时候，试着画画递归树找思路。就算做对了，画图也能加深对递归算法的理解。 123456789101112131415161718192021func maxPathSum(root *TreeNode) int { maxSum := math.MinInt32 var dfs func(*TreeNode) int dfs = func(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) innerMaxSum := left + right + root.Val maxSum = max(maxSum, innerMaxSum) outputMaxSum := root.Val + max(left, right) return max(outputMaxSum, 0) } dfs(root) return maxSum}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"二叉树的直径","text":"二叉树的直径 思路：深度优先搜索 一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。 123456789101112131415161718192021func diameterOfBinaryTree(root *TreeNode) int { res := 0 var dfs func(root *TreeNode) int dfs = func(root *TreeNode) int{ if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) res = max(res, left+right+1) return max(left, right) + 1 } dfs(root) return res - 1}func max(a, b int) int { if a &gt; b { return a } return b}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"title":"二叉树的层次遍历","text":"二叉树层次遍历 思路：队列遍历 首先根元素入队。 如果队列不为空，则得到当前队列的长度n, 依次从队列拉出n个元素，并将元素的左右子树节点放入队列，重复迭代直到队列为空。 12345678910111213141516171819202122232425// 时间复杂度 O（N）， 空间复杂度 O（N）func levelOrder(root *TreeNode) [][]int { ret := make([][]int, 0) if root == nil { return ret } q := []*TreeNode{root} for len(q) &gt; 0 { n := len(q) tempLevel := make([]int, n) for i := 0; i &lt; n; i++ { node := q[i] tempLevel[i] = node.Val if node.Left != nil { q = append(q, node.Left) } if node.Right != nil { q = append(q, node.Right) } } q = q[n:] ret = append(ret, tempLevel) } return ret}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"title":"二叉树的锯齿形层序遍历","text":"二叉树的锯齿形层序遍历 12345678910111213141516171819202122232425262728293031// 时间复杂度 O（N）， 空间复杂度 O（N）func zigzagLevelOrder(root *TreeNode) [][]int { ret := make([][]int, 0) if root == nil { return ret } q := []*TreeNode{root} isReverse := false for len(q) &gt; 0 { n := len(q) tempLevel := make([]int, n) for i := 0; i &lt; n; i++ { node := q[i] if isReverse { tempLevel[n-i-1] = node.Val } else { tempLevel[i] = node.Val } if node.Left != nil { q = append(q, node.Left) } if node.Right != nil { q = append(q, node.Right) } } q = q[n:] isReverse = !isReverse ret = append(ret, tempLevel) } return ret}","link":"/2024/03/17/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"算法/二叉树","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"pages":[]}